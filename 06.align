#!/bin/bash
set -euo pipefail

SLANG="$1"
SRC_BATCH="$2"
REF_BATCH="$3"

SHARD_ID=$(basename $(dirname $SRC_BATCH))
SRC_BATCH_ID=$(basename $SRC_BATCH)
REF_BATCH_ID=$(basename $REF_BATCH)

PAIR_FORMAT='{"shard": "'$SHARD_ID'", "'$SLANG'":'$SRC_BATCH_ID', "'$TARGET_LANG'":'$REF_BATCH_ID'}'
TIME_FORMAT='{"user":"%U", "system":"%S", "elapsed":"%E", "cpu":"%P", "text":%X, "data":%D, "max":%M, "inputs":%I, "output":%O, "major":%F, "minor":%R, "swaps":%W}'

TMPSFX=${JOB_ID:-$$}

filter_long_pairs() {
	# Prevent extreme stuff from making it to bleualign, which would be unhappy
	while read -r line; do
		if [ $(( $(cut -f4 <<< "$line" | base64 -d | wc -l) * $(cut -f5 <<< "$line" | base64 -d | wc -l)  )) -lt "$1" ]; then
			echo "$line"
		fi
	done
}

export -f filter_long_pairs

# Why is this line causing so much trouble, as if the output is no longer just
# single lines but merged rubbish
#| parallel --tmpdir=$TMPDIR -j4 --halt 2 --pipe --line-buffer filter_long_pairs 1000000000\
# Other attempt, whichs works, but I rather not need (insert just before the parallel bleualign line)
#| filter_long_pairs 2000000000\

/usr/bin/time -f '{"task":"docalign", "pair":'"$PAIR_FORMAT"', "time":'"$TIME_FORMAT"'}' \
${DOCALIGN} -j ${THREADS} --threshold 0.1 \
	${SRC_BATCH}/tokenised_${TARGET_LANG%~*}.gz \
	${REF_BATCH}/tokenised_${TARGET_LANG%~*}.gz \
| tee ${SRC_BATCH}/pairs-${TARGET_LANG%~*}-${REF_BATCH_ID}.txt \
| cut -f2-3 \
| ${DOCJOIN} \
	-li\
	-ri\
	-l ${SRC_BATCH}/sentences.gz\
	-r ${REF_BATCH}/sentences.gz\
	-l ${SRC_BATCH}/sentences_${TARGET_LANG%~*}.gz\
| /usr/bin/time -f '{"task":"bleualign", "pair":'"$PAIR_FORMAT"', "time":'"$TIME_FORMAT"'}' \
parallel \
	--tmpdir=$TMPDIR \
	-j${THREADS} \
	--halt 2 \
	--pipe \
	--group \
	-l 1 \
	${BLEUALIGN} --bleu-threshold 0.2 \
| gzip -c \
> ${SRC_BATCH}/aligned-${REF_BATCH_ID}.$TMPSFX.gz
mv ${SRC_BATCH}/aligned-${REF_BATCH_ID}{.$TMPSFX,}.gz

